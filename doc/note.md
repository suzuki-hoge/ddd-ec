# 事後録
## 感想
箇条書き

+ 言語
  + Haskellでやってもしょうがないけど、JavaはだるすぎるのでJavaっぽいScalaで書いた
  + 同じことはJavaでも出来るはず　`match`？`instanceOf`でもすれば良いんじゃねーの？
  + HaskellのEitherモナドたまらん
  + Haskell書きたい
+ 適当にお題作ったけど、案外大変だった
  + 特に支払いの検証、発送の検証、支払いと発送の検証が面倒だった
  + メールとか明細とか発送とか、リポジトリ多すぎた
+ DomainService
  + domain層の`XxxService`がDomainService的な？
  + DomainServiceはMock化なしで単体テストが出来ること
  + つまり副作用を禁じる
  + 個人的には副作用が無いので`static`であるべきだと思っている
  + 今回はscalaなので`object`にした　IntelliJでファイルマークが変わるから結構良かった
+ コンビニコードの場合のみ住所に変換する（DBアクセスをする）、みたいな条件ロジックはリポジトリには書かないでみた
  + リポジトリに書くとドメインロジックがドメイン外になるから
  + 型だけでやることを察するのが難しくなるから
+ 適当具合
  + Databaseは適当にハードコード
  + packageは適当
  + DIとかしてない
  + なによりも、案外書くことが多くて飽きたｗ
+ 例外
  + isbnの数が6以上の場合例外とする、はバリデーションなのか、ドメインエラーなのか
  + 後者だとした
  + Formは複数を正しく受け付けることが責務、数のチェックは仕様だから
+ 実装の感じ
  + まずdomainを書く
  + repositoryのinterface部分を書く
  + domainのテストを書く
  + formを書く
  + formのテストを書く
  + ここまでで6-7割の労力を使うイメージ　また図も並行して実装と行ったり来たりしながら書く
  + api作る
  + serviceの型だけ書いてapiと繋ぐ
  + serviceでrepositoryだけ呼び繋げる（repositoryの実装はまだ）
  + repositoryの実装書く
  + repositoryの実装のテスト書く
  + serviceのテスト書く
  + apiのテスト書く
+ ドメイン以降は、設計はトップダウン・実装はボトムアップ、って感じ？
  + domainの設計・実装の段階で、どれだけ型をどんどんと繋げていくイメージが出来ているかが肝
+ やっぱ副作用をドメインから抹殺しきることを大前提に置くと、経験値が得られる感じがする
  + これをしないと、ドメインから書き切ったり、ドメインだけを単体テストしたり出来なくなる
  + この書き方を数回したけど、apiを作る以降でdomainに手直しが入ることがすごい少ない気がする
  + 逆に消化試合感出るので飽きが来るけどｗ
+ 図を書いた
  + クラス図は悪くないけど適しきってないなーって思った
  + `C = XxxDomainService(A, B)`みたいな、変換や条件を示すには合わない
  + けど仕様ってそういう所にあるきがする

総括すると、飽きたので中途半端になった
相変わらず完成まで行かない

## ステップ02以降
思いつきネタ

### 商品増減
+ 会社の上の方がCDを売るぞーと言い出して本の他にCDが出来る
  + Point: 本のジャンルと商品のジャンルを上手くモデリングする
+ 今度はゲームを売ると言いだして、また増える
+ もっと上の方が今時CDはないだろと言って、CDはなくなる
  + Point: 無くなった物の適切な削除

### キャンペーン
+ 本とCDを同時に買うと10%Off
  + Point: ドメインサービスを増やすという発想になるか
+ 本とゲームで5%Off
  + Point: 同上、また、CDとの合わせ技の対応
+ で、後日CDはなくなる、と

### 会員
プレミアム会員が出来る

+ こいつは優先して発送される
  + Point: 会員と発送を混ぜない
+ こいつはキャンペーンのパーセンテージに3%加えられる
  + Point: ドメインサービスの切り方

### UI層の変更
+ なんかレガシーなシステムと連携するために、XMLで受け、返す
  + Point: ドメイン層はかわらない

RestAPIを提供するため、SessionID認証ではなくTokenで認証するAPIを新設する

+ このTokenは月10回までしか利用できない
  + Point: 認証のことはAPI層で済ます

### 状態管理
#### キャンセル
以下の場合はキャンセルが出来る

+ 商品を引き当てて、発送する前まで
+ 発送をしたが、着荷する前まで

キャンセルされた商品は在庫になる

#### 発送予定変更
以下の場合は発送予定変更が出来る

+ 商品を引き当てて、発送する前まで

#### 総括
+ 在庫状態
+ 引当済み
  + キャンセルで在庫に戻る
  + 発送予定日を変更できる
  + 発送予定日を持つ
+ 発送済み
  + キャンセルで在庫に戻る
  + 着荷予定日を持つ
+ 受取済み

+ Point
  + エンティティを状態毎に分離すること
  + 巨大Entityに`Optional(ReceiveScheduleDate)`とかしない
  + `godEntity.getReceiveScheduleDate().getOrThrow(() -> new E('このEntityは発送済みではありません'))`とか絶対しない
  + 実行例外を無くす
